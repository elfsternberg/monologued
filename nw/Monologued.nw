% -*- Mode: noweb; noweb-code-mode: rust-mode ; noweb-doc-mode: latex-mode -*-
\documentclass{article}
\usepackage{noweb}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{fontspec, xunicode, xltxtra}
\setmainfont{Centaur MT Std}

\begin{document}

% Generate code and documentation with:
%
% noweave -filter l2h -delay -x -html backbonestore.nw | htmltoc > backbonestore.html
% notangle -Rstore.js backbonestore.nw > store.js
% notangle -Rindex.html backbonestore.nw > index.html

\section{Introduction}

\textbf{Monologued is an RFC-1288 server.}

Monologued is an RFC-1288 (RUIP: Remote User Information Protocol)
server with a restrict (Q1 only) syntax.  It has been mostly written as
an exercise in Rust to learn the MIO (Metal I/O) and libc interfaces, as
well as Rust in general.

RUIP offers two syntaces:

\begin{lstlisting}
{Q1}    ::= [{W}|{W}{S}{U}]{C}
{Q2}    ::= [{W}{S}][{U}]{H}{C}
{U}     ::= username
{H}     ::= @hostname | @hostname{H}
{W}     ::= /W 
{S}     ::= <SP> | <SP>{S}
{C}     ::= <CRLF>
\end{lstlisting}

Monologued supports only the Q1 query, and can be restricted further to
limit the Q1 query only to those users in a defined group, or even to a
list of usernames specified in a file or on the command line.  It
delivers only a user's `.plan` file.

In the spirit of traditional IP protocol rules, Monologued is fairly
liberal in its treatment of \{S\} and \{C\}, attempting to make sense of
them.  It's input buffer is limited to 1KB by default; the maximum
output size of a .plan file is 128KB.  Changing these limits would
require a recompile.

\subsection{Literate Program}

A note: this article was written with the
\nwanchorto{http://en.wikipedia.org/wiki/Literate_programming}{Literate
  Programming} toolkit
\nwanchorto{http://www.cs.tufts.edu/~nr/noweb/}{Noweb}. Where you see
something that looks like \texttt{\<\<this\>\>}, it's a placeholder for
code described elsewhere in the document.  Placeholders with an equal
sign at the end of them indicate the place where that code is defined.
The link (U-\>) indicates that the code you're seeing is used later in
the document, and (\<-U) indicates it was used earlier but is being
defined here.

\subsection{Revision}

This is version 0.2a of \textbf{Monologued}.  

Instructions on generating the code and documentation from this document
are provided in the accompanying Makefile.

\subsection{Organization}

An RUIP server is a fairly straightforward programming exercise.  As
we're using MIO, I expect to be using the [[select/poll]] feature with
which to interact with the outside world, and [[libc]]'s [[getpwnam_r]],
[[getpwent_r]], and [[lstat]] functionality to determine the presence
and availability of the user's [[.plan]] file.

To that end, the basic functionality will be, "For a given username,
return either the plan or a message about discovery failure."  This is
straight-up railway-oriented programming, with more precise failures the
further down into the syntax we go. 

The structure of Monologued is that of a basic server, which parses the
request and either fails or passes the username to the handler; the
username lookup either passes or fails (this is important because if you
delete the username but not the home directory, the inotify feature
fails); if the username lookup passes we request the plan.  If the plan
is present, we return it.  Otherwise we return nothing and close the
connection.

\subsection{The Plan}

Since this is mostly an exercise in learning Rust and MIO, there will be
a few iterations of the server.  I am currently doing the first one.

\begin{enumerate}
\item Simple echo server that returns a line
\item Echo server that returns either a found username or
  nothing
\item Echo server that also re-uses tokens
\item Finger server that returns a plan
\item Finger server that caches plans
\item Finger server that deletes plans upon inotification
\end{enumerate}   

\section{The server}

Since Monologued is a server, we need to receive and send data through
network sockets.  The data needs to be read until either it hits a size
limit or a CRLF pair is seen, after which the contents of the read
buffer are analyzed for a valid username.  

For this version, we're just creating a very simple line-based echo
server that takes whatever it's given and just echos it back.

For MIO, that means:

<<main.rs>>=
use mio::*;
use mio::{TcpListener, TcpStream};
@

One thing we do care about is the server, and another is the maximal
number of connections.

<<constants>>=
const MAX_CONNECTIONS: usize = 1024;
const MAX_LINE: usize = 128;
const LISTENER: mio::Token = mio::Token(0);
@ 

In the [main] function, the primary responsibility is to allocate the
port, set up a TcpListener (a server socket intended primarily to
receive requests for new transactions), a Poll (a generalize abstraction
of POSIX \texttt{select(2)} and some post-Posix asynchronous system
calls, such as \texttt{poll(2)}, \texttt{epoll(7)} and \texttt{kqueue}),
and an Events collection which will track the readiness of asynchronous
events. We then register the listener with the poll, and start polling.

<<main>>=
fn main() {
    let address="0.0.0.0:6567".parse().unwrap();
    let listener = TcpListener::bind(&address).unwrap();
    let mut events = Events::with_capacity(MAX_CONNECTIONS);
    let poll = Poll::new().unwrap();
@ 

Registering involves putting the server socket into the polling object,
with a token that will be used to recover the socket requesting handling
during a poll event, a [Ready] that indicates this socket is primarily
for reading, and a list of options.  The only options immediately
available are ``edge'' and ``level''; for the most part, we want
``edge'' related events.

<<main>>=
    poll.register(&listener, LISTENER, Ready::readable(), PollOpt::edge()).unwrap();
@ 

And finally the main loop, in which we handle the tokens as we find
them:

<<main>>=
    loop {
        poll.poll(&mut events, None).unwrap();
        for event in &events {
            match event.token() {
                LISTENER => {
                    <<new connection>>
                }
                (token) => {
                    

    
    
    
    

                   
@ 


\end{document}

